snippet gdef "google function with docstring"
def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
	"""${3:docstring for $1}

	Args:
		${4:}
	"""
endsnippet

snippet gflag_string "google flags"
flags.DEFINE_string("${2:param_name}", ${3:value}, "${4:explaination}")
endsnippet

snippet gflag_bool "google flags"
flags.DEFINE_bool("${2:param_name}", ${3:value}, "${4:explaination}")
endsnippet

snippet gflag_integer "google flags"
flags.DEFINE_integer("${2:param_name}", ${3:value}, "${4:explaination}")
endsnippet

snippet gflag_float "google flags"
flags.DEFINE_float("${2:param_name}", ${3:value}, "${4:explaination}")
endsnippet

snippet gnewpy "google new python format"
# Lint as: python3
"""TODO(yukunfg): DO NOT SUBMIT without one-line documentation for test.

TODO(yukunfg): DO NOT SUBMIT without a detailed description of test.
"""

from __future__ import absolute_import  # Not necessary in a Python 3
from __future__ import division  # Not necessary in a Python 3-only module
from __future__ import google_type_annotations  # Not necessary in a Python 3
from __future__ import print_function  # Not necessary in a Python 3-only module

from absl import app
from absl import flags

FLAGS = flags.FLAGS


def main(argv):
  if len(argv) > 1:
    raise app.UsageError('Too many command-line arguments.')

if __name__ == '__main__':
  app.run(main)
endsnippet

snippet filelists "file lists"
import os
for file_dir, _, filenames in os.walk("${1:dir}"):
    for filename in filenames:
			file_path = os.path.join(file_dir, filename)
endsnippet

snippet forfull "for full statement"
# (start, stop, step). produce: 0, 1, 2, 3
for i in range(${1:0}, ${2:4}, 1):
	${3:}
endsnippet

snippet timediff "time difference"
import datetime
${1:start_time} = datetime.datetime.now()
${2:end_time} = datetime.datetime.now()
${3:time_elapsed} = f"{$2 - $1}"
print(f"time_elapsed: {$3}")
endsnippet

snippet argtrue "argument true"
parser.add_argument('--${1:flag}', action='store_true',
					help='${2:help}')
endsnippet

snippet readfile "read file"
${1:fh} = open(${2:file_path}, "r")
for line in $1:
	line = line.strip()
	# Skip empty lines
	if line == "":
		continue
$1.close()
endsnippet

snippet readfilew "read file with statement"
with open(${1:file_path}, 'r') as ${2:fh}:
	for line in $2:
		line = line.strip()
		# Skip empty lines
		if line == "":
			continue
endsnippet

snippet regexeg "regex examples"
regex = re.compile(pattern)
result = regex.search(string)
# Equivalent to
search_result = re.search(pattern, string)

# Common function
# findall(pattern, string): list (empty list if no position)
# search(pattern, string): None if no position else return object. Search matches once.
# for result: group(0): entire match; grou(1) first parenthesized subgroup and so on.

# replace:
# result = re.sub('abc',  'def', input)           # Replace pattern abc -> def
# backrefernces, the whole pattern will be replaced. If want to keep some part, just group it.
# result = re.sub("(\d+) (\w+)", r"\2 \1")
# usually use re.subn to return (new_string, number_of_subs_made).
endsnippet

snippet argparse "argument parse"
import argparse
parser = argparse.ArgumentParser(
	description='Description of your program',
	formatter_class=argparse.ArgumentDefaultsHelpFormatter
)
# args['foo'] is None
parser.add_argument(
	'-f', '--foo',
	help='Description for foo argument',
	required=True
)
# another way to avoid double dash
parser.add_argument(
	'-f',
	help='Description for foo argument',
	required=True
)
parser.add_argument(
	'-b', '--bar',
	help='Description for bar argument',
	required=True
)
# add default='xx' if you want
#parser.add_argument('-b', type=int or float)
# Setting a varable True or False
# args['w'] = False or True
parser.add_argument('-w', action='store_true')
args = vars(parser.parse_args())
# another way to directly access variable like args.foo
args = parser.parse_args()
# args now is a dict
args['f']
endsnippet

snippet readstdin "read from stdin"
import fileinput
for line in fileinput.input():
	line = line.strip()
	# Skip empty lines
	if line == "":
		continue
# Or
import sys
fh = sys.stdin
endsnippet

snippet  readalllines "read all lines"
# Read and strip lines from file
lines = [line.strip() for line in open(${1:file_path}, 'r').readlines()]
# Skip empty lines
lines = [line for line in lines if line]
endsnippet

snippet  filenote "file note"
"""
Author      : Yukun Feng
Date        : `date +%Y/%m/%d`
Email       : yukunfg@gmail.com
Description : ${1:write brief description here}
"""
endsnippet

# Some overwriting snippet from vim-snippets
snippet #!3
#!/usr/bin/env python3
endsnippet

snippet for_em "fore enumerate"
for i, ${1:ele} in enumerate(${2:your_list}, 0):
	pass
endsnippet

# usage of reference. It can also be refered winthin a new variable
snippet path "path process"
import os
${1:file_path} = os.path.expanduser($1)
head, tail = os.path.split($1)
endsnippet

# sort dict
snippet sort_dict "sort dict"
import collections
${1:sorted_dict} = collections.OrderedDict(
    sorted(${2:your_dict}.items(), reverse=${3:False}, key=lambda t: t[${4:0}])
)
for k, v in $1.items():
    print(k, v)
endsnippet

snippet debug "debug"
import pdb
pdb.set_trace()
endsnippet

snippet idebug "idebug"
import ipdb
ipdb.set_trace()
endsnippet

snippet textfreq "text frequency"
from collections import Counter
counter = Counter()
lines = [
	counter.update(line.strip().split())
	for line in open(${1:file_path}, 'r').readlines()
]
endsnippet

snippet textvocab "build vocab from counter"
import torchtext
# freqs, itos, stoi
vocab = torchtext.vocab.Vocab(counter, specials=[])
endsnippet

snippet print_variables "print variables"
def print_variables(variables, namespace=globals()):
    for variable in variables:
        var_name = "None"
        for name in namespace:
            if namespace[name] is variable:
                var_name = name
                break
        print(f"{var_name}: {variable}")
endsnippet

snippet line_process "line_process"
import sys
import re

if __name__ == "__main__":
    fh_list = []
    if len(sys.argv) >= 2:
        extra_params = sys.argv[1:]
        for file_path in extra_params:
            fh = open(file_path, 'r')
            fh_list.append(fh)
    else:
        fh = sys.stdin
        fh_list.append(fh)

    count = 0
    for fh in fh_list:
        for line in fh:
            line = line.strip()
            if line == "":
                continue
            items = line.split()
            count += 1

    for fh in fh_list:
        fh.close()
endsnippet
